#ifndef __lcm_cpp_hpp__
#define __lcm_cpp_hpp__

/**
 * C++ API for liblcm.  Primarily intended for use with the C++ message
 * bindings.
 *
 * The C++ API is a purely header implementation, and has the same linking 
 * requirements as the C API.  The 
 */

#include <string>
#include <vector>
#include <lcm/lcm.h>

namespace lcm {

class Subscription;

/**
 * Stores the raw bytes and timestamp of a received message.
 */
struct ReceiveBuffer {
    void *data;
    uint32_t data_size;
    int64_t recv_utime;
};

/**
 * Core communications class for the C++ API.
 *
 * @include <lcm/lcm-cpp.hpp>
 * 
 */
class LCM {
    public:
        /**
         * Initializes the LCM instance and connects it to the specified LCM
         * network.  See the documentation on lcm_handle() in the C API for
         * details on how lcm_url is formatted.
         *
         * @return 0 on success, -1 on failure.
         * @sa lcm_create()
         */
        inline LCM(std::string lcm_url="");

        inline ~LCM();

        /**
         * Checks if initialization succeeded during object construction.
         *
         * @return true if initialization succeeded and the instance appears
         * ready for communication, false if not.
         */
        inline bool good() const;

        /**
         * Publishes a raw data message.
         *
         * @param channel the channel to publish the message on.
         * @param data data buffer containing the message to publish
         * @param datalen length of the message, in bytes.
         *
         * @return 0 on success, -1 on failure.
         */
        inline int publish(const std::string& channel, void *data, 
                unsigned int datalen);

        /**
         * Publishes a message.  This template method is designed for use with
         * C++ classes generated by lcm-gen.
         *
         * @param channel the channel to publish the message on.
         * @param msg the message to publish.
         *
         * @return 0 on success, -1 on failure.
         */
        template<class MessageType>
        inline int publish(const std::string& channel, const MessageType *msg);

        /**
         * Returns a file descriptor or socket that can be used with select(),
         * poll(), or other event loops for asynchronous notification of
         * incoming messages.
         *
         * @return a non-negative number on success, -1 if something is wrong.
         * @sa lcm_get_fileno()
         */
        inline int fileno();

        /**
         * Wait for and dispatch one message.
         *
         * @return 0 on success, -1 if something went wrong.
         * @sa lcm_handle()
         */
        inline int handle();

        /**
         * Subscribe an object to a channel, with automatic message decoding.
         *
         * @param channel The channel to subscribe to.  This is treated as a
         * regular expression implicitly surrounded by '^' and '$'.
         * @param handlerMethod A class method pointer identifying the callback
         * method.
         * @param handler A class instance that the callback method will be
         * invoked on.
         *
         * This method is designed for use with C++ classes generated by
         * lcm-gen.
         *
         * For example:
         *
         * \code
         * #include <exlcm/example_t.lcm>
         * class MyMessageHandler {
         *   void onMessage(const lcm::ReceiveBuffer* rbuf, const std::string& channel, 
         *           const exlcm::example_t* msg) {
         *      // do something with the message
         *   }
         * };
         *
         * // elsewhere...
         *
         * MyMessageHandler handler;
         * lcm->subscribe("CHANNEL", &MyMessageHandler::onMessage, &handler);
         *
         * \endcode
         *
         * @return a Subscription object that can be used to adjust the
         * subscription and unsubscribe.  The Subscription object is managed by
         * the LCM class, and is automatically destroyed when its LCM instance
         * is destroyed.
         */
        template <class MessageType, class MessageHandlerClass>
        Subscription* subscribe(const std::string& channel, 
            void (MessageHandlerClass::*handlerMethod)(const ReceiveBuffer* rbuf, const std::string& channel, const MessageType* msg),
            MessageHandlerClass* handler);

        /**
         * Subscribe an object to a channel, without automatic message decoding.
         *
         * @return a Subscription object that can be used to adjust the
         * subscription and unsubscribe.  The Subscription object is managed by
         * the LCM class, and is automatically destroyed when its LCM instance
         * is destroyed.
         */
        template <class MessageHandlerClass>
        Subscription* subscribe(const std::string& channel,
            void (MessageHandlerClass::*handlerMethod)(const ReceiveBuffer* rbuf, const std::string& channel),
            MessageHandlerClass* handler);

        /** 
         * Subscribe a function callback to a channel, with automatic message
         * decoding.
         *
         * @return a Subscription object that can be used to adjust the
         * subscription and unsubscribe.  The Subscription object is managed by
         * the LCM class, and is automatically destroyed when its LCM instance
         * is destroyed.
         */
        template <class MessageType, class ContextClass> 
        Subscription* subscribeFunction(const std::string& channel,
                void (*handler)(const ReceiveBuffer* rbuf, 
                                const std::string& channel, 
                                const MessageType *msg, 
                                ContextClass context),
                ContextClass context);

        /**
         * Subscribe a function callback to a channel, without automatic
         * message decoding.
         *
         * @return a Subscription object that can be used to adjust the
         * subscription and unsubscribe.  The Subscription object is managed by
         * the LCM class, and is automatically destroyed when its LCM instance
         * is destroyed.
         */
        template <class ContextClass>
        Subscription* subscribeFunction(const std::string& channel,
                void (*handler)(const ReceiveBuffer* rbuf,
                                const std::string& channel,
                                ContextClass context),
                ContextClass context);

        /**
         * Unsubscribes a message handler.
         *
         * @param subscription a Subscription object previously returned by a
         * call to subscribe() or subscribeFunction().
         */
        inline void unsubscribe(Subscription* subscription);

    private:
        lcm_t *lcm;

        std::vector<Subscription*> subscriptions;
};

/**
 * Represents a channel subscription.
 */
class Subscription {
    public:
        virtual ~Subscription() {}

        /**
         * Adjusts the maximum number of received messages that can be queued
         * up for this subscription.  Setting this to a low number may reduce
         * overall latency at the expense of dropping more messages.
         * Conversely, setting this to a high number may drop fewer messages at
         * the expense of increased latency.  A value of 0 indicates no limit,
         * and should be used very carefully.
         *
         * @param the maximum queue size, in messages.  The default is 30.
         *
         */
        inline int setQueueCapacity(int num_messages);

    friend class LCM;
    protected:
        lcm_subscription_t *c_subs;
};

/**
 * Represents a single event in a log file.
 *
 * This struct is the C++ counterpart for lcm_eventlog_event_t.
 *
 * @sa lcm_eventlog_event_t
 */
struct LogEvent {
    int64_t eventnum;
    int64_t timestamp;
    std::string channel;
    int32_t datalen;
    void* data;
};

/**
 * Read and write LCM log files.
 *
 * This class is the C++ counterpart for lcm_eventlog_t.
 *
 * @sa lcm_eventlog_t
 */
class LogFile {
    public:
        /**
         * Constructor.  Opens the specified log file for reading or writing.
         * @path the file to open
         * @mode "r" (read mode) or "w" (write mode)
         *
         * @sa lcm_eventlog_create()
         */
        inline LogFile(const char* path, const char* mode);

        /**
         * Destructor.  Closes the log file.
         */
        inline ~LogFile();

        /**
         * @return true if the log file is ready for reading/writing.
         */
        inline bool good() const;

        /**
         * Reads the next event in the log file.  Valid in read mode only.
         *
         * The LogFile class manages the memory of the read event.
         *
         * @return the next event, or NULL if the end of the log file has been
         * reached.
         */
        inline const LogEvent* readNextEvent();

        /**
         * Positions the file pointer as close to the specified timestamp in
         * the log file as possible.  Valid in read mode only.
         *
         * @sa lcm_eventlog_seek_to_timestamp()
         */
        inline int seekToTimestamp(int64_t timestamp);

        /**
         * Writes an event to the log file.  Valid in write mode only.
         * @param the event to write.  The timestamp, channel, datalen, and
         * data fields should be filled in.  The eventnum field will be
         * automatically filled in.
         *
         * @return 0 
         * @sa lcm_eventlog_write_event()
         */
        inline int writeEvent(LogEvent* event);

    private:
        LogEvent curEvent;
        lcm_eventlog_t* eventlog;
        lcm_eventlog_event_t* last_event;
};

#define __lcm_cpp_impl_ok__
#include "lcm-cpp-impl.hpp"
#undef __lcm_cpp_impl_ok__

}
#endif
