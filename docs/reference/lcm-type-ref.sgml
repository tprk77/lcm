<refentry id="tutorial-lcm-language" revision="08 Aug 2008">
<refmeta>
  <refentrytitle>The LCM Type Specification Language</refentrytitle>
</refmeta>

<refnamediv>
  <refname>The LCM Type Specification Language</refname>
  <refpurpose>The usage and features of the LCM type
  language.</refpurpose>
</refnamediv>

<refsect1>
  <title>Introduction</title>
  <para>
    LCM is a utility designed to generate platform-independent marshalling
    and unmarshalling functions for user-defined data types. It is similar
    to XDR, though it is written with greater type safety in mind, and
    with the goal of natively supporting other languages such as Java (in
    addition to C).
  </para>
    <para>
    <emphasis>TODO</emphasis>
    </para>

  <para>
    Goals: Cross platform, multi-language, type safe.
  </para>

  <para>
    Development history: MIT DGC 2007.
  </para>
</refsect1>

<refsect1>
  <title>Related Work</title>
  <para>
    XDR, XML/RPC, IPC's thingie
  </para>
</refsect1>

<refsect1>
  <title>Type Specifications</title>
  <para>
    Type specifications are contained in files with an ".lcm" file
    type. They are conventially named in lower case with underscores
    between words: e.g., the type "wind_speed_t" is defined in the
    file "wind_speed_t.lcm". The utility <emphasis>lcm-gen</emphasis>
    converts an LCM type specification into a language-dependent
    implementation.
  </para>

  <refsect2>
    <title>Structs</title>
    
    <para>LCM structs are compound types consisting of other types. We
      begin with a simple struct named "temperature_t" that contains a
      64 bit integer named "utime" and a 64 bit floating point number
      named "degCelsius". Two types of comments are also illustrated.
    </para>

    <programlisting>
      struct temperature_t 
      {
          int64_t   utime;         // Timestamp, in microseconds

          /* Temperature in degrees Celsius. A "float" would probably
           * be good enough, unless we're measuring temperatures during
           * the big bang. Note that the asterisk on the beginning of this
           * line is not syntactically necessary, it's just pretty.
           */
          double    degCelsius;    
      }
    </programlisting>

    <para>
      This declaration must appear in a file named "temperature_t.lcm".
    </para>

    <para>LCM types do not contain pointers (but arrays are supported, see
      below): this eliminates the possibility of circular references.
    </para>

    <para>Before we go further, let's take a look at the various
      primitive types available.</para>

    <refsect3>
      <title>Primitive Types</title>
      
      <para>LCM supports a number of primitive types: int8_t, int16_t,
	int32_t, int64_t, byte, float, double, string, and boolean. The
	integer types are all signed (as is necessary to ensure easy
	inter-operation with Java, which lacks unsigned types) and are
	encoded in network byte order.</para>
      
      <para>The type 'byte' is encoded the same way as int8_t. However,
	there are instances in which buffers of data (such as a JPEG
	image) must be sent across the network. These buffers of data
	must be decoded by some additional software. The type 'byte' can
	be used by a type designer to help convey the notion that the
	data is opaque, and should not be interpreted (literally) as an
	array of 8 bit integers.
      </para>
      
      <para>Floating point types are encoded using the IEEE 32 and 64
	bit formats. An LCM implementation may not use any other
	encoding. The 32 and 64 bit quantities are transmitted in
	network byte order.
      </para>
      
      <para>The boolean type is encoded as a single byte whose value is
	either 0 or 1. An array of N booleans will require N bytes.
      </para>
      
      <para>The string type encodes a NULL-terminated UTF-8 string. The
	string is sent as a 32 bit integer comprising the total length of
	string in bytes (including terminating NULL character) followed by
	the bytes of the string (again, including the NULL character).
      </para>
    </refsect3>
    
    <refsect3>
      <title>Arrays</title>
 
      <para>
	LCM supports multi-dimensional arrays consisting of
	primitives, structs, or enums. The number of dimensions in the
	array are declared by the LCM type declaration: you cannot
	encode an LCM type that consists of a variable-dimension
	array. In contrast, variable-sized arrays are fine. Consider
	this example:
      </para>
      
      <programlisting>
	struct point2d_list_t
        {
	   int32_t npoints;
	   double  points[npoints][2];
        }
      </programlisting>

      <para>
	This example shows a two-dimensional array declaration
	consisting of both variable-length and fixed-length
	components. In a variable-length declaration, the variable
	that contains the length must be declared prior to its use as
	an array length. Also note that the length variable (npoints,
	in the example above) must be an integer type, and must always
	have a value greater than or equal to zero.
      </para>

      <para>
	When arrays are encoded and decoded, each dimension's size is
	already known: it is either a constant (given by the LCM type
	declaration), or it was a previously encoded/decoded
	variable. Thus, an array is encoded simply by recursively
	encoding each element of the array, with inner-most dimensions
	being encoded together. In other words, the array above would
	be encoded in the order points[0][0], points[0][1],
	points[1][0], points[1][1], points[2][0], points[2][1], etc.
      </para>

    </refsect3>
  </refsect2>
  
  <refsect2>
    <title>Enumerations/Constants</title>
    
    <para>
      Not really enumerations. Allow bitfield operations.
    </para>
    <para>
      <emphasis>TODO</emphasis>
    </para>
  </refsect2>

  <para>
      Type safety, hash computation. (Refer to appendix 1).
    </para>
</refsect1>

<refsect1>
  <title>Namespaces</title>
  <para>
  <emphasis>TODO</emphasis>
  </para>
</refsect1>

<refsect1>
  <title>Performance Considerations</title>
  <para>
    Performance evaluation?
  </para>
    <para>
    <emphasis>TODO</emphasis>
    </para>
</refsect1>

<refsect1>
  <title>Future Work</title>
  <para>
  <emphasis>TODO</emphasis>
  </para>
</refsect1>

<refsect1>
  <title>Appendix 1: Fingerprint Computation</title>
  <para>
    Fingerprints ensure that the encoding and decoding methods agree on
    the format of a data type. The fingerprints are a function,
    recursively, of all of the types that a type contains. This creates a
    potential problem when types could be mutually recursive: we must
    avoid an infinite recursion.
  </para>
  
  <para>
    The basic idea is for each type to have a "base" fingerprint, which
    we'll denote for type "A" as "K_A". K_A is a constant derived from the
    lcm type description (and it's stored as lcm_struct->hash). We wish to
    compute the actual fingerprint (or hash), A(), which is a function of
    all of A's contained types.
  </para>
  
  <para>
    In addition, so that we can recognize a recursion, the A() function
    takes an argument, which is a list of the types already visited. E.g.,
    C(&lt;A,B&gt;) indicates that we wish to compute the hash of type C, given
    that C is a member of type B, which is a member of type A.  We avoid
    recursions by setting C(&lt;list&gt;) = 0 if &lt;list&gt; contains C. 
  </para>
  
  <para>
    The contribution of primitive types is handled via the K_A; there is
    no recursion for them.
  </para>
  
  <para>
    A small wrinkle arises from the above definitions: if types A, B, and
    C are mutually recursive, we can have two types with the same
    hash. This is clearly undesirable. We fix this by making the order of
    recursion relevant: at each node in the tree, we rotate the value
    (bitwise) 1 bit to the left. A type that is included at recursion
    depth N has its contribution rotated by N bits.
  </para>
  
  <para>
    Note that this mechanism is entirely unnecessary for enumerations
    (they cannot contain other types); for enumerations, we just use the
    hash in lcmenum->hash.
  </para>
  
<para>PSEUDO-CODE </para>

<programlisting>
  v = compute_hash(type, parents)
  
  if type is member of parents
     return 0

  v = K_type;

  for each members m of type
      v += compute_hash(m, &lt;parents, type&gt;)

  return rot_left(v);
</programlisting>

<para>
  When encoding/decode a type T, we would use compute_hash(T,
  &lt;&gt;) as the hash function.
</para>

<para>EXAMPLE</para>

<programlisting>
struct A
{
        B b;
        C c;
}

struct B
{
        A a;
}

struct C
{
        B b;
}
</programlisting>

<para>
  Diagramatically, we can compute their hashes by showing the children
  of each branch. We use lower case to indicate a terminal leaf (where
  the leaf is the same class as one of its parents).
</para>

<programlisting>
         A                B                  C
       /   \              |                  |
      B     C             A                  B
      |     |            / \                 |
      a     B           b   C                A
            |               |               / \
            a               b              b   c

A() = R{K_A + R{K_B}} + R{K_C + R{K_B}}}

B() = R{K_B + R{K_A + R{K_C}}}

C() = R{K_C + R{K_B + R{K_A}}}
</programlisting>

<para>
  Note that without the rotations, B() == C().
</para>

</refsect1>

</refentry>
